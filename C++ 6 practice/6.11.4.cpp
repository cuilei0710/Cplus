/*
 * @Author: 崔小葵
 * @Date: 2020-11-14 19:28:22
 * @Last Modified by: 崔小葵
 * @Last Modified time: 2020-11-22 22:02:42
 */
#include <iostream>
#include <iomanip>

using namespace std;

const unsigned strsize = 50;
const unsigned ArSize = 20;

void diasplay(struct bop, int, int);

// Benevolent Order of Programmers name structure
struct bop
{
    char fullname[strsize]; // real name
    char title[strsize];    // job title
    char bopname[strsize];  // secret BOP name
    int preference;         // 0 = fullname, 1 = title, 2 = bopname
};

int main()
{
    void display(bop * boparray, int x, int n);
    int n;
    char ch;
    cout << "How many people you want to register: ";
    (cin >> n).get();
    struct bop boparray[n];

    for (int i = 0; i < n; i++)
    {
        cout << "The " << i + 1 << ":\n"
             << "Fullname: ";
        cin.getline(boparray[i].fullname, ArSize);
        cout << "Title: ";
        cin.getline(boparray[i].title, ArSize);
        cout << "Bopname: ";
        cin.getline(boparray[i].bopname, ArSize);
        cout << "Preference: ";
        (cin >> boparray[i].preference).get();
    }
    cout << "The input is completed!" << endl;
    system("cls"); // clear screen
    cout << "Benevolent Order of Programmers Report\n";
    cout.flags(ios::left);
    cout << setw(20) << "a. display by name"
         << "b. display by title" << endl;
    cout << setw(20) << "c. display by bopname"
         << "d. display by preference" << endl;
    cout << "q. quit" << endl;
    cout << "Enter your choice: ";
    while (cin >> ch)
    {
        if (ch == 'q')
        {
            break;
        }
        switch (ch)
        {
        case 'a':
            display(boparray, 0, n);
            break;
            // Why I didn’t use the address of the array here?
            // It’s because I just output the array instead of changing the value of the original array.
        case 'b':
            display(boparray, 1, n);
            break;
        case 'c':
            display(boparray, 2, n);
            break;
        case 'd':
            display(boparray, 3, n);
            break;
        default:
            break;
        }
        cout << "Next choice: ";
    }
    cout << "Bye!" << endl;
    system("pause");
    return 0;
}

void display(struct bop *boparray, int x, int n)
{
    switch (x)
    {
    case 0:
        for (int i = 0; i < n; i++)
        {
            cout << boparray[i].fullname << endl;
        }
        break;
    case 1:
        for (int i = 0; i < n; i++)
        {
            cout << boparray[i].title << endl;
        }
        break;
    case 2:
        for (int i = 0; i < n; i++)
        {
            cout << boparray[i].bopname << endl;
        }
        break;
    case 3:
        for (int i = 0; i < n; i++)
        {
            cout << boparray[i].preference << endl;
        }
        break;
    default:
        break;
    }
}
/*Note: For the getline() function used in the above code,
the reason why I add (cin >> n).get() to the line where n is input is because when cin reads n,
The newline character generated by the enter key stays in the input queue.
When cin.getline() sees the newline character later,
it will be regarded as a blank line, and the null character will be assigned to cin.getline(bopname[i].fullname )
This will make it impossible to input later in the program,
you can replace it with cin.get(Member, Size);
or replace the above cin >> n with (cin >> n).get(),
and the following should also be replaced.
*/